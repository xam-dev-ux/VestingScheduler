{
  "language": "Solidity",
  "sources": {
    "contracts/VestingScheduler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title VestingScheduler\n * @dev Contrato para gestionar múltiples vesting schedules con fees configurables\n * @notice Permite crear vesting schedules individuales o en batch con diferentes configuraciones\n */\ncontract VestingScheduler is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    // Estructura para definir un vesting schedule\n    struct VestingSchedule {\n        address beneficiary;        // Beneficiario del vesting\n        address token;             // Token ERC20 a vestear\n        uint256 totalAmount;       // Cantidad total a vestear\n        uint256 startTime;         // Timestamp de inicio\n        uint256 cliffDuration;     // Duración del cliff en segundos\n        uint256 duration;          // Duración total del vesting en segundos\n        uint256 amountClaimed;     // Cantidad ya reclamada\n        bool revocable;            // Si el vesting puede ser revocado\n        bool revoked;              // Si el vesting ha sido revocado\n        address creator;           // Creador del vesting\n    }\n\n    // Mapeo de ID de vesting a su schedule\n    mapping(uint256 => VestingSchedule) public vestingSchedules;\n\n    // Mapeo de beneficiario a lista de IDs de vesting\n    mapping(address => uint256[]) public beneficiaryVestings;\n\n    // Mapeo de creador a lista de IDs de vesting\n    mapping(address => uint256[]) public creatorVestings;\n\n    // Contador de vesting schedules\n    uint256 public vestingCount;\n\n    // Fee percentage (en basis points, 100 = 1%)\n    uint256 public feePercentage;\n\n    // Dirección donde se acumulan los fees\n    address public feeCollector;\n\n    // Fees acumulados por token\n    mapping(address => uint256) public accumulatedFees;\n\n    // Mínimo de duración de vesting (1 día)\n    uint256 public constant MIN_VESTING_DURATION = 1 days;\n\n    // Máximo fee percentage (10%)\n    uint256 public constant MAX_FEE_PERCENTAGE = 1000;\n\n    // Eventos\n    event VestingCreated(\n        uint256 indexed vestingId,\n        address indexed beneficiary,\n        address indexed token,\n        uint256 amount,\n        uint256 startTime,\n        uint256 duration,\n        address creator\n    );\n\n    event TokensClaimed(\n        uint256 indexed vestingId,\n        address indexed beneficiary,\n        uint256 amount\n    );\n\n    event VestingRevoked(\n        uint256 indexed vestingId,\n        address indexed beneficiary,\n        uint256 amountReturned\n    );\n\n    event FeePercentageUpdated(uint256 oldFee, uint256 newFee);\n\n    event FeeCollectorUpdated(address oldCollector, address newCollector);\n\n    event FeesWithdrawn(address indexed token, uint256 amount);\n\n    event BatchVestingCreated(uint256 indexed startId, uint256 count);\n\n    /**\n     * @dev Constructor\n     * @param _feePercentage Fee inicial en basis points (100 = 1%)\n     * @param _feeCollector Dirección que recibirá los fees\n     */\n    constructor(uint256 _feePercentage, address _feeCollector) Ownable(msg.sender) {\n        require(_feePercentage <= MAX_FEE_PERCENTAGE, \"Fee too high\");\n        require(_feeCollector != address(0), \"Invalid fee collector\");\n\n        feePercentage = _feePercentage;\n        feeCollector = _feeCollector;\n    }\n\n    /**\n     * @dev Crea un nuevo vesting schedule\n     * @param beneficiary Dirección del beneficiario\n     * @param token Dirección del token ERC20\n     * @param totalAmount Cantidad total a vestear\n     * @param startTime Timestamp de inicio (0 para iniciar inmediatamente)\n     * @param cliffDuration Duración del cliff en segundos\n     * @param duration Duración total del vesting en segundos\n     * @param revocable Si el vesting puede ser revocado\n     */\n    function createVesting(\n        address beneficiary,\n        address token,\n        uint256 totalAmount,\n        uint256 startTime,\n        uint256 cliffDuration,\n        uint256 duration,\n        bool revocable\n    ) external nonReentrant whenNotPaused returns (uint256) {\n        require(beneficiary != address(0), \"Invalid beneficiary\");\n        require(token != address(0), \"Invalid token\");\n        require(totalAmount > 0, \"Amount must be > 0\");\n        require(duration >= MIN_VESTING_DURATION, \"Duration too short\");\n        require(cliffDuration <= duration, \"Cliff > duration\");\n\n        uint256 actualStartTime = startTime == 0 ? block.timestamp : startTime;\n        require(actualStartTime >= block.timestamp, \"Start time in past\");\n\n        // Calcular fee\n        uint256 fee = (totalAmount * feePercentage) / 10000;\n        uint256 amountAfterFee = totalAmount - fee;\n\n        // Transferir tokens desde el creador\n        IERC20(token).safeTransferFrom(msg.sender, address(this), totalAmount);\n\n        // Acumular fee\n        if (fee > 0) {\n            accumulatedFees[token] += fee;\n        }\n\n        // Crear vesting schedule\n        uint256 vestingId = vestingCount++;\n\n        vestingSchedules[vestingId] = VestingSchedule({\n            beneficiary: beneficiary,\n            token: token,\n            totalAmount: amountAfterFee,\n            startTime: actualStartTime,\n            cliffDuration: cliffDuration,\n            duration: duration,\n            amountClaimed: 0,\n            revocable: revocable,\n            revoked: false,\n            creator: msg.sender\n        });\n\n        beneficiaryVestings[beneficiary].push(vestingId);\n        creatorVestings[msg.sender].push(vestingId);\n\n        emit VestingCreated(\n            vestingId,\n            beneficiary,\n            token,\n            amountAfterFee,\n            actualStartTime,\n            duration,\n            msg.sender\n        );\n\n        return vestingId;\n    }\n\n    function createBatchVesting(\n        address[] calldata beneficiaries,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata startTimes,\n        uint256[] calldata cliffDurations,\n        uint256[] calldata durations,\n        bool[] calldata revocables\n    ) external nonReentrant whenNotPaused returns (uint256[] memory) {\n        uint256 count = beneficiaries.length;\n        require(count > 0, \"Empty array\");\n        require(\n            tokens.length == count &&\n            amounts.length == count &&\n            startTimes.length == count &&\n            cliffDurations.length == count &&\n            durations.length == count &&\n            revocables.length == count,\n            \"Array length mismatch\"\n        );\n\n        uint256[] memory vestingIds = new uint256[](count);\n        uint256 startId = vestingCount;\n\n        for (uint256 i = 0; i < count; i++) {\n            require(beneficiaries[i] != address(0), \"Invalid beneficiary\");\n            require(tokens[i] != address(0), \"Invalid token\");\n            require(amounts[i] > 0, \"Amount must be > 0\");\n            require(durations[i] >= MIN_VESTING_DURATION, \"Duration too short\");\n            require(cliffDurations[i] <= durations[i], \"Cliff > duration\");\n\n            uint256 actualStartTime = startTimes[i] == 0 ? block.timestamp : startTimes[i];\n            require(actualStartTime >= block.timestamp, \"Start time in past\");\n\n            uint256 fee = (amounts[i] * feePercentage) / 10000;\n            uint256 amountAfterFee = amounts[i] - fee;\n\n            IERC20(tokens[i]).safeTransferFrom(msg.sender, address(this), amounts[i]);\n\n            if (fee > 0) {\n                accumulatedFees[tokens[i]] += fee;\n            }\n\n            uint256 vestingId = vestingCount++;\n            vestingIds[i] = vestingId;\n\n            vestingSchedules[vestingId] = VestingSchedule({\n                beneficiary: beneficiaries[i],\n                token: tokens[i],\n                totalAmount: amountAfterFee,\n                startTime: actualStartTime,\n                cliffDuration: cliffDurations[i],\n                duration: durations[i],\n                amountClaimed: 0,\n                revocable: revocables[i],\n                revoked: false,\n                creator: msg.sender\n            });\n\n            beneficiaryVestings[beneficiaries[i]].push(vestingId);\n            creatorVestings[msg.sender].push(vestingId);\n\n            emit VestingCreated(\n                vestingId,\n                beneficiaries[i],\n                tokens[i],\n                amountAfterFee,\n                actualStartTime,\n                durations[i],\n                msg.sender\n            );\n        }\n\n        emit BatchVestingCreated(startId, count);\n        return vestingIds;\n    }\n\n    function getClaimableAmount(uint256 vestingId) public view returns (uint256) {\n        VestingSchedule memory schedule = vestingSchedules[vestingId];\n        if (schedule.revoked) return 0;\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) return 0;\n        uint256 vestedAmount = _calculateVestedAmount(schedule);\n        return vestedAmount - schedule.amountClaimed;\n    }\n\n    function _calculateVestedAmount(VestingSchedule memory schedule) private view returns (uint256) {\n        if (block.timestamp < schedule.startTime + schedule.cliffDuration) return 0;\n        if (block.timestamp >= schedule.startTime + schedule.duration) return schedule.totalAmount;\n        uint256 timeFromStart = block.timestamp - schedule.startTime;\n        return (schedule.totalAmount * timeFromStart) / schedule.duration;\n    }\n\n    function claim(uint256 vestingId) external nonReentrant {\n        VestingSchedule storage schedule = vestingSchedules[vestingId];\n        require(schedule.beneficiary == msg.sender, \"Not beneficiary\");\n        require(!schedule.revoked, \"Vesting revoked\");\n        uint256 claimableAmount = getClaimableAmount(vestingId);\n        require(claimableAmount > 0, \"Nothing to claim\");\n        schedule.amountClaimed += claimableAmount;\n        IERC20(schedule.token).safeTransfer(schedule.beneficiary, claimableAmount);\n        emit TokensClaimed(vestingId, schedule.beneficiary, claimableAmount);\n    }\n\n    function revokeVesting(uint256 vestingId) external nonReentrant {\n        VestingSchedule storage schedule = vestingSchedules[vestingId];\n        require(schedule.creator == msg.sender, \"Not creator\");\n        require(schedule.revocable, \"Not revocable\");\n        require(!schedule.revoked, \"Already revoked\");\n        schedule.revoked = true;\n        uint256 vestedAmount = _calculateVestedAmount(schedule);\n        uint256 claimableAmount = vestedAmount - schedule.amountClaimed;\n        if (claimableAmount > 0) {\n            schedule.amountClaimed += claimableAmount;\n            IERC20(schedule.token).safeTransfer(schedule.beneficiary, claimableAmount);\n        }\n        uint256 returnAmount = schedule.totalAmount - vestedAmount;\n        if (returnAmount > 0) {\n            IERC20(schedule.token).safeTransfer(schedule.creator, returnAmount);\n        }\n        emit VestingRevoked(vestingId, schedule.beneficiary, returnAmount);\n    }\n\n    function setFeePercentage(uint256 newFeePercentage) external onlyOwner {\n        require(newFeePercentage <= MAX_FEE_PERCENTAGE, \"Fee too high\");\n        uint256 oldFee = feePercentage;\n        feePercentage = newFeePercentage;\n        emit FeePercentageUpdated(oldFee, newFeePercentage);\n    }\n\n    function setFeeCollector(address newFeeCollector) external onlyOwner {\n        require(newFeeCollector != address(0), \"Invalid address\");\n        address oldCollector = feeCollector;\n        feeCollector = newFeeCollector;\n        emit FeeCollectorUpdated(oldCollector, newFeeCollector);\n    }\n\n    function withdrawFees(address token) external onlyOwner nonReentrant {\n        uint256 amount = accumulatedFees[token];\n        require(amount > 0, \"No fees to withdraw\");\n        accumulatedFees[token] = 0;\n        IERC20(token).safeTransfer(feeCollector, amount);\n        emit FeesWithdrawn(token, amount);\n    }\n\n    function pause() external onlyOwner { _pause(); }\n    function unpause() external onlyOwner { _unpause(); }\n    function getBeneficiaryVestings(address beneficiary) external view returns (uint256[] memory) { return beneficiaryVestings[beneficiary]; }\n    function getCreatorVestings(address creator) external view returns (uint256[] memory) { return creatorVestings[creator]; }\n    function getVestingDetails(uint256 vestingId) external view returns (address beneficiary, address token, uint256 totalAmount, uint256 startTime, uint256 cliffDuration, uint256 duration, uint256 amountClaimed, uint256 claimableAmount, bool revocable, bool revoked, address creator) {\n        VestingSchedule memory schedule = vestingSchedules[vestingId];\n        return (schedule.beneficiary, schedule.token, schedule.totalAmount, schedule.startTime, schedule.cliffDuration, schedule.duration, schedule.amountClaimed, getClaimableAmount(vestingId), schedule.revocable, schedule.revoked, schedule.creator);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": ["ast"]
      }
    }
  }
}
